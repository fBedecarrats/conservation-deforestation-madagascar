[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Impact des aires protégées sur la déforestation : guide de formation pratique",
    "section": "",
    "text": "Préface\nCe contenu a été développé afin de servir de support pédagogique pour l’atelier “évaluation des politiques” de la session 2022 des Universités en sciences sociales Tany Vao. Les universités Tany Vao visent à dispenser une formation à la recherche de haut niveau à l’attention de doctorants et jeunes chercheurs de Madagascar et d’Afrique de l’Ouest. Après deux jours de plénières, les participants se répartissent pendant cinq jours entre quatre ateliers parallèles : socioéconomie, éthnoégologie, anthropologie et évaluation des politiques.\nL’atelier “évaluation des politiques” adopte une approche axée l’économétrie et la science des données. Il alterne des sessions théorique et pratique. Conformément au thème phare de Tany Vao pour 2022 (“environnement et sociétés”), le cas d’étude choisi pour servir de fil rouge à ces travaux est l’impact des aires protégées sur la déforestation.\nPhoto en couverture : “Déforestation à Madagascar” © IRD - Bernard Moizo"
  },
  {
    "objectID": "00-intro.html#outils-utilisés",
    "href": "00-intro.html#outils-utilisés",
    "title": "Introduction",
    "section": "Outils utilisés",
    "text": "Outils utilisés\n\nNotebook Quarto\nLes éléments ci-dessous constituent le support pour les sessions pratiques de cet atelier. Ils sont réalisés en suivant une approche ouverte et reproductible fondée sur un document de type “notebook” (Bédécarrats and Hobeika 2017). Un notebook rassemble à la fois :\n\nles lignes de code du programme statistique qui traite les données ;\nles résultats (calculs, tableaux, graphiques…) produits lors de l’exécution de ce programme ;\nle texte rédigé par les auteurs pour expliquer le processus d’analyse et en interpréter les résultats.\n\nL’intérêt du format notebook, par rapport à l’utilisation de documents distincts pour traiter les données d’une part, et en analyser les résultats d’autre part, est multiple :\n\nfavoriser la reproductibité de la recherche (tout le processus de traitement, analyse, interprétation peut être inspecté et dupliqué) ;\nfaciliter le travail du chercheur (une interface pour tout faire) ; et\nassurer les meilleures pratiques de collaboration (utilisation pour le versionnage, partage et fusion des travaux les outils performants développés en programmation informatique).\n\nLes traitements sont réalisés en R, qui est à la fois un logiciel et un langage open sources dédiés à l’analyse de données. Les traitements R sont inclus dans un document Quarto, un format qui exécute aussi bien des codes en R, Python, e rendus dans différents formats (LaTeX/PDF, HTML ou Word).\nLa mise en forme des rendus Quarto est paramétrable. Ici, on a notamment placé un argument code-fold: true dans le fichier _quarto.yml. Cela fait que les blocs de code ne sont pas visible dans le rendu web par défaut : il faut cliquer sur “code” pour les déplier.\n\n\nMapme.biodiversity\nOn s’appuie sur le package R {mapme.biodiversity}, développé par la KfW dans le cadre de l’initiative commune MAPME qui associe la KfW et l’AFD. Le package {mapme.biodiversity} facilite l’acquisition et la préparation d’un grand nombre de données (CHIRPS, Global Forest Watch, FIRMS, SRTM, Worldpop…) et calculer un grand nombre d’indicateurs de manière harmonisée (active_fire_counts, biome classification, land cover classification, population count, precipitation, soil properties, tree cover loss, travel time…). Une documentation riche est disponible sur le portail dédié du package en question (Kluve et al. 2022).\nOn mobilise aussi les codes d’analyse d’impact développés par la même équipe et mises à disposition dans le dépôt Github: https://github.com/openkfw/mapme.protectedareas. Le code développé par l’équipe est assez complexe. A des fins pédagogiques et pour s’assurer qu’on l’a bien compris, on propose ici une version simplifiée (en cours de développement).\n\n\nOnyxia/SSP Cloud\nLes sources pour l’ensemble du code source et du texte du présent document est accessible sur Github à l’adresse suivante : https://github.com/fBedecarrats/conservation-deforestation-madagascar. Les analyses sont menées sur la plateforme SSP Cloud, mises à disposition par l’INSEE pour les data scientists travaillant pour des administrations publiques. Il s’agit d’une instance de stockage de données massif (S3) et de calcul haute performance (cluster Kubernetes) disposant d’une interface simplifiée permettant à l’utilisateur de configurer, lancer et administrer facilement des environnements de traitement de données (RStudio server, Jupyter lab ou autres…). Le code est conçu pour s’exécuter de la même manière en local sur un PC, mais la préparation des données sera certainement beaucoup plus longue à exécuter.\n\n\nLibrairies R\nOutre Mapme.biodiversity, on mobilise une série de librairies (appelées “packages” en R), qui facilitent grandement l’analyse. Elles sont listées dans le bloc ci-dessous.\n\n\nCode\n# # Le package est en cours de développement, toujours installer la version en cours\n# remotes::install_github(\"mapme-initiative/mapme.biodiversity\", \n#                         upgrade = \"always\")\n\nlibrairies_requises <- c( # On liste les librairies dont on a besoin\n  \"tidyverse\", # Une série de packages pour faciliter la manipulation de données\n  \"readxl\", # Pour lire les fichiers excel (Carvalho et al. 2018)\n  \"cowplot\", # Pour arranger des graphiques en illustrations composées\n  \"gt\", # Pour des rendus graphiques harmonisés html et pdf/LaTeX\n  \"sf\", # Pour faciliter la manipulation de données géographiques\n  \"wdpar\", # Pour télécharger simplement la base d'aires protégées WDPA\n  \"webdriver\", # requis pour installer phantomjs pour wdpar\n  \"tmap\", # Pour produire de jolies carte\n  \"geodata\", # Pour télécharger simplement les frontières administratives\n  \"tidygeocoder\", # pour obtenir les coordo GPS d'un point à partir de son nom\n  \"maptiles\", # Pour télécharger des fonds de carte \n  \"mapme.biodiversity\", # Acquisition et traitement des données du projet\n  \"plm\", # Linear Models for Panel Data and robust covariance matrices\n  \"broom\", # pour reformater simplement les rendus de tests statistiques\n  \"stargazer\", # Reformater de manière plus lisible les résumé des régressions\n  \"MatchIt\", # Pour le matching\n  #\"glm\", # Modèles linéaires généralisés (pour le PSM)\n  \"optmatch\", # Fonctions d'optimisation du matching\n  \"rgee\",\n  \"rgeeExtra\",\n  \"cobalt\") # Tables et graphs d'équilibre des groupes de matching\n  \n# On regarde parmi ces librairies lesquelles ne sont pas installées\nmanquantes <- !(librairies_requises %in% installed.packages())\n# On installe celles qui manquent\nif(any(manquantes)) install.packages(librairies_requises[manquantes])\n\n## On charge toutes les librairies requises\n## On fera le chargement dans le chapitres pour expliciter les manips\n# invisible(lapply(librairies_requises, require, character.only= TRUE))\n\n# TODO : repasser les paramètres ci-dessous en clair dans les chapitres\n# Système de coordonnées géographiques utilisées pour le projet : EPSG:29739\nmon_scr <- \"EPSG:29739\" # correspondant à Tananarive / UTM zone 39S\n# Surface des hexagones en km2\ntaille_hex <- 5\n# Taille des titres des cartes\ntaille_titres_cartes = 1\n# on crée un dossier de données si pas déjà disponible\ndir.create(\"data\")\n# Désactiver les notations scientifiques\noptions(scipen =999)"
  },
  {
    "objectID": "00-intro.html#mode-demploi",
    "href": "00-intro.html#mode-demploi",
    "title": "Introduction",
    "section": "Mode d’emploi",
    "text": "Mode d’emploi\n\n\n\n\nBédécarrats, Florent, and Alexandre Hobeika. 2017. “Une Alternative à Word : Écrire En RMarkdown.” Billet. Data Sciences Sociales. http://data.hypotheses.org/1144.\n\n\nKluve, Jochen, Johannes Schielain, Melvin Wong, and Yota Eilers. 2022. “The KfW Protected Areas Portfolio: A Rigorous Impact Evaluation.” Frankfürt."
  },
  {
    "objectID": "01-aires_protegees.html#données-de-lassociation-vahatra",
    "href": "01-aires_protegees.html#données-de-lassociation-vahatra",
    "title": "1  Aires protégées",
    "section": "1.1 Données de l’association Vahatra",
    "text": "1.1 Données de l’association Vahatra\nLes études sur les aires protégées s’appuient fréquemment sur la base WDPA (World Database on Protected Area), consultable en ligne sur https://protectedplanet.net. On s’aperçoit dans le cas de Madagascar que cette base de données comporte de nombreuses erreurs (qu’on étudiera plus bas). La base rassemblée par l’association Vahatra dans le cadre de la monographie qu’elle a coordonnée sur l’ensemble des aires protégées terrestres malgaches semble beaucoup plus fiable (Goodman et al. 2018). Les données en question sont disponibles sur le portail https://protectedareas.mg avec une licence creative commons (CC-BY).\nLe bloc de code ci-dessous (cliquer sur “code” pour visualiser), présente la séquence d’opérations réalisées pour préparer les données.Pour comprendre certaines opérations contenues dans le bloc de code, il est utile d’être familier de la syntaxe de R et des packages du tidyverse. Voir le chapitre (10_fondamentaux_R?).\n\n\nCode\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(sf)\nlibrary(tmap)\nlibrary(geodata)\nlibrary(cowplot)\nlibrary(wdpar)\nlibrary(gt) # Pour faciliter le rendu des tableaux (et ils sont jolis)\n\n# Le shapefile est composé d'une série de fichiers, (.shp, .dbf, .prj, .shx)\n# qui doivent avoir le même nom et être au même endroits pour être ouverts en\n# même temps. Comme souvent, ils sont compressés ensemble dans un fichier zip.\n# On commence par dézipper (décompresser) ce fichier.\nunzip(\"data/Vahatra98AP.zip\", exdir = \"data/Vahatra\")\n# On importe dans R en pointant vers le fichier .shp, mais c'est bien toute la\n# collection de fichiers homonymes .shp, .dbf, .shx qui est chargée.\nAP_Vahatra <- st_read(\"data/Vahatra/Vahatra98AP.shp\", quiet = TRUE) %>%\n  # Il manque la projection (pas de fichier .prj), on la spécifie à la main\n  st_set_crs(\"EPSG:4326\") # EPSG 4325 = WSG 84 = le standard pour le web\n\n# L'option ci-dessous est un peu cryptique : des caractéristiques topologiques\n# de la carte source sont incompatibles avec la possibilité d'avoir des objets\n# sphériques dans sf. Cela disparait si on désactive cette possibilité\nsf_use_s2(FALSE) \n\n# Identification des dates ----------------------------------------------------\n# Cette section est un brin complexe, à base de manipulation de chaînes de \n# caractères et de dates\n\n# Détecte les dates écrites 2 avril 2020 ou 02 avril 2020, etc.\ndate_ecrite <- \"[:digit:]{1,2} [:alpha:]* [:digit:]{4}\"\n# Détecte les dates écrites 02/04/20 ou 02.04.20 ou 02.04.2020, etc.\ndate_abrev <- \"[:digit:]{2}[:punct:][:digit:]{2}[:punct:][:digit:]{2,4}\"\n# Des années écrites à 2 chiffres\ndate_ecrite_an_abrev <- \"[:digit:]{1,2} [:alpha:]* [:digit:]{4}\"\n# Détecte l'une ou l'autre des formes précédentes\ntoute_date <- paste(date_ecrite, date_abrev, date_ecrite_an_abrev, sep = \"|\")\n# Détecte une mention d'année seule : 1984, 2015, etc.\nannee_seule <- \"[:digit:]{4}\"\n# Détecte les formes indicatrices d'un changement\nmention_changement <- \"Changement|changement|anciennement|actuel|auparavant\"\n# Une fonction qui traduit les dates écrites en toutes lettre du français à \n# l'anglais (pour les parser ensuite car ça ne fonctionne qu'en anglais)\ntrad_dates <- function(date_fr) {\n  str_replace_all(date_fr,\n                  c(\"janvier\" = \"January\",\n                    \"fevrier\" = \"February\",\n                    \"mars\" = \"March\",\n                    \"avril\" = \"April\",\n                    \"mai\" = \"May\",\n                    \"juin\" = \"June\",\n                    \"juillet\" = \"July\",\n                    \"aout\" = \"August\",\n                    \"septembre|setembre\" = \"September\",\n                    \"octobre\" = \"October\",\n                    \"novembre\" = \"November\",\n                    \"decembre|decmbre\" = \"December\"))\n}\n# Cette fonction remplace 01.04.58 par 01.04.1958 et marche avec . ou /\n# On indique avec limite le nombre d'année où on considère que c'est 1900 vs 2000\ncomplete_annee <- function(date_abrev, limite = 20) {\n  if (str_detect(date_abrev, \"([:punct:])([:digit:]{2})[:punct:]?$\")) {\n    date_abrev <- str_remove(date_abrev, \":punct:]?$\")\n    if (as.numeric(str_extract(date_abrev, \"[:digit:]{2}$\")) > limite) {\n      date_abrev <- str_replace(date_abrev, \n                                \"([:punct:])([:digit:]{2})[:punct:]?$\", \"\\\\119\\\\2\")\n    } else {\n      date_abrev <- str_replace(date_abrev, \n                                \"([:punct:])([:digit:]{2})[:punct:]?$\", \"\\\\120\\\\2\")\n    }\n  }\n  return(date_abrev)\n}\n# La fonction précédente est unitaire, on la transforme pour qu'elle s'applique à une liste.\ncomplete_liste_dates <- function(liste_dates) {\n  map(liste_dates, complete_annee)\n}\n\nAP_Vahatra <- AP_Vahatra %>%\n  # On extrait les dates des champs de texte\n  mutate(date_creation = str_extract_all(creation, toute_date), \n         # Une date a un format incohérent, on la recode à la main\n         date_creation = ifelse(creation == \"Créée le 07 aout 04\",\n                                \"07 aout 2004\", date_creation),\n         date_creationA = map(date_creation, 1), # La 1ère date\n         date_creationB = map(date_creation, 2)) %>% # Si 2 dates, la seconde\n  # On traduit les mois en anglais pour une conversion au format date\n  mutate(across(c(\"date_creationA\", \"date_creationB\"), trad_dates)) %>%\n  mutate(across(c(\"date_creationA\", \"date_creationB\"), complete_liste_dates)) %>%\n  mutate(across(c(\"date_creationA\", \"date_creationB\"), dmy)) %>%\n  mutate(date_creation = case_when(is.na(date_creationB) ~ date_creationA,\n                                    date_creationA > date_creationB ~ date_creationB,\n                                    date_creationA <= date_creationB ~ date_creationA),\n         date_modification = case_when(is.na(date_creationB) ~ date_creationB,\n                                       date_creationA < date_creationB ~ date_creationB,\n                                       date_creationA >= date_creationB ~ date_creationA),\n         # On repère si il y a eu un changement de statut ou de frontières\n         mention_changement = str_detect(creation, mention_changement)) %>%\n    # On enlève les colonnes inutiles\n  select(-date_creationA, -date_creationB) %>%\n  # On place les colonnes créées à gauche pour les inspecter facilement\n  relocate(date_creation:mention_changement, .after = creation) \n\n# Après une vérification manuelle, on remarque les données de l'association Vahatra comportent des mentions incomplètes pour certaines aires, qui n'ont pas été extraites:\n\n\n# Lokobe : 31 décembre 1927\nAP_Vahatra <- AP_Vahatra %>%\n  mutate(date_creation = case_when(nom == \"Lokobe\" ~ ymd(\"1927-12-31\"),\n                                   nom == \"Mantadia\" ~ ymd(\"1989-01-11\"),\n                                   TRUE ~ date_creation),\n         date_modification = case_when(nom == \"Bemaraha\" ~ ymd(\"2011-07-06\"),\n                                       nom == \"Lokobe\" ~ ymd(\"2011-07-06\"),\n                                       nom == \"Tsaratanana\" ~ ymd(\"2011-07-06\"),\n                                       nom == \"Pic d'Ivohibe\" ~ ymd(\"2015-04-28\"),\n                                       nom == \"Mantadia\" ~ ymd(\"2002-08-07\"),\n                                       TRUE ~ date_modification)) %>%\n  st_make_valid() # fiabilise qu'il n'y a pas d'erreurs topologiques\n# dir.create(\"AP_Vahatra\")\n# st_write(AP_Vahatra, \"out/AP_Vahatra.shp\")\n# writexl::write_xlsx(st_drop_geometry(AP_Vahatra), \"AP_Vahatra.xlsx\")\n\n\nLe bloc de code suivant génère une carte interactive. On a également inclus des lignes de code qui permettent de formater la carte joliment pour un rendu figé (pdf/LaTeX, html statique, word), mais ce code est “commenté”, c’est-à-dire qu’on a placé des dièses au début de chaque ligne, de sorte qu’il ne s’exécute pas (R n’exécute jamais ce qui se trouve à droite d’un # sur une ligne). Pour plus de détails sur la manière dont on produit des cartes, voire l’annexe : Cartes simples en R\n\n\nCode\ncontour_mada <- gadm(country = \"Madagascar\", resolution = 1, level = 0,\n                     path = \"data/GADM\") %>%\n  st_as_sf()\n# On génère un rendu cartographique\ntmap_mode(\"view\") # En mode interactif\ntm_shape(contour_mada) +\n  tm_borders() +\n  tm_shape(AP_Vahatra) + \n  tm_polygons(col = \"cat__iucn\", alpha = 0.6, title = \"Catégorie IUCN\") +\n  tmap_options(check.and.fix = TRUE) # +\n\n\n\n\n\n\n\nCode\n# Les dièses en début de ligne font que ce qui suit ne s'exécute pas.\n# La suite est uniquement pour les rendus fixes (tmap_mode = \"plot\"), p. ex. pour les pdf\n  # # NB : on note les positions en majuscules quand on veut coller aux marges\n  # tm_credits(\"Sources: WDPA et GADM\", position = c(\"RIGHT\", \"BOTTOM\"),\n  #            size = 0.6) +\n  # tm_layout(main.title = \"Aires protégées de Madagascar\",\n  #           # NB : position en minuscules pour laisser un espace avec la marge\n  #           main.title.position = c(\"center\", \"top\"),\n  #           main.title.size = taille_titres_cartes,\n  #           legend.position = c(\"left\", \"top\"),\n  #           legend.outside = TRUE)\n\n\nOn peut également réaliser un graphique qui présente l’historique de création des aires protégées. Pour plus de précisions sur la manière de produire des graphiques en R, voir l’annexe correspondante.\n\n\nCode\n# On ordonne les nom d'aires protégées dans l'ordre de leur séquence de création\nordre_chrono_AP <- AP_Vahatra %>%\n  arrange(desc(date_creation), desc(nom)) %>%\n  pull(nom)\n# On transforme le champ \"nom\" de caractère, à une catégorisation ordonnée où\n# l'ordre correspond \nAP_Vahatra_carte <- AP_Vahatra %>%\n  mutate(nom = factor(nom, levels = ordre_chrono_AP),\n         cat_taille = case_when(hectares > 300000 ~ 2,\n                                hectares > 150000 ~ 1.5,\n                                hectares >  50000 ~ 1,\n                                             TRUE ~ 0.5)) %>%\n  rename(`Catégorie IUCN` = cat__iucn)\n\n# On crée un graph pour les anciennetés\ngraph_gauche <- AP_Vahatra_carte %>%\n  ggplot(aes(x = date_creation, xend = ymd(\"2022-10-01\"), y = nom, yend = nom, \n                   color = `Catégorie IUCN`)) +\n  geom_segment(size = 2) +\n  ggtitle(\"Ancienneté\") +\n  theme(axis.ticks.y = element_blank(),\n        legend.position = \"none\",\n        axis.title = element_blank(),\n        axis.text.x.bottom =  element_text(angle = 45, hjust = 1),\n        axis.text.x.top = element_text(angle = -45, hjust = 1)) + \n  scale_x_date(sec.axis = dup_axis())\n\ngraph_droite <- AP_Vahatra_carte %>%\n  ggplot(aes(x = 0, xend = hectares/100, y = nom, yend = nom, \n                   color = `Catégorie IUCN`)) +\n  geom_segment(size = 2) + \n  ggtitle(\"Surface (km2)\") +\n  theme(axis.text.y = element_blank(),\n        axis.title = element_blank(),\n        axis.text.x.bottom =  element_text(angle = 45, hjust = 1),\n        axis.text.x.top = element_text(angle = -45, hjust = 0),\n        legend.position = \"none\") + \n  scale_x_continuous(sec.axis = dup_axis())\n\nlegende <- get_legend(graph_gauche  +\n                        guides(color = guide_legend(nrow = 1)) +\n                        theme(legend.position = \"bottom\"))\n\n# On colle les deux\ngraphs <- plot_grid(graph_gauche, graph_droite, rel_widths = c(2.2, 1),\n          nrow = 1)\nplot_grid(graphs, legende, ncol = 1,\n          rel_heights = c(1,.1))\n\n\n\n\n\nIl faut aussi s’assurer qu’on filtre bien les entités analysées selon un critère pertinent. Actuellement, on exclut les aires marines. Il pourrait toutefois sembler utile d’écarter les aires dont le statut de protection est considéré comme trop faible. Il pourrait aussi être pertinent de ne garder que les aires protégées comportant un niveau minimum de couvert forestier : autrement, cela signifie que la forêt n’est pas un habitat pertinent pour les écosystèmes que la démarche de conservation cherche à protéger dans cette aire."
  },
  {
    "objectID": "01-aires_protegees.html#world-database-on-protected-areas",
    "href": "01-aires_protegees.html#world-database-on-protected-areas",
    "title": "1  Aires protégées",
    "section": "1.2 World Database on Protected Areas",
    "text": "1.2 World Database on Protected Areas\nOn commence par télécharger et présenter ces données.\n\n\nCode\n# Downloading Protected areas from Madagascar\nWDPA_Mada <- wdpa_fetch(\"Madagascar\", wait = TRUE,\n                      download_dir = \"data/WDPA\") \n\n# TODO: inclure graph et description des données."
  },
  {
    "objectID": "01-aires_protegees.html#comparaison-des-données-vahatra-et-wdpa",
    "href": "01-aires_protegees.html#comparaison-des-données-vahatra-et-wdpa",
    "title": "1  Aires protégées",
    "section": "1.3 Comparaison des données Vahatra et WDPA",
    "text": "1.3 Comparaison des données Vahatra et WDPA\nOn commence par visualiser les différences spatiales entre les polygones, en affichant les 10 qui sont les plus différents entre les WDPA et Vahatra.\n\n\nCode\n# On harmonise les noms qui sont parfois notés différemment entre les sources\nAP_Vahatra <- AP_Vahatra %>%\n  mutate(nom_wdpa = case_when(\n    nom == \"Corridor Forestier Bongolava\" ~ \"Corridor forestier Bongolava\",\n    nom == \"Ranobe PK32\" ~ \"Ranobe PK 32\",\n    str_detect(nom, \"Ambositra-Vondrozo\") ~ \"Corridor Forestier Ambositra Vondrozo\",\n    nom == \"Réserve deTampolo\" ~ \"Réserve de Tampolo\",\n    nom == \"Bombetoka Beloboka\" ~ \"Bombetoka Belemboka\",\n    nom == \"Ampananganandehibe-Behasina\" ~ \"Ampanganandehibe-Behasina\",\n    nom == \"Forêt Sacrée Alandraza Analavelo\" ~ \"Analavelona\", # vérfié sur carte : les mêmes\n    nom == \"Réserve speciale Pointe à Larrée\" ~ \"Réserve spéciale Pointe à Larrée\", \n    nom == \"Vohidava-Betsimalaho\" ~ \"Vohidava Betsimalao\", \n    nom == \"Anjanaharibe Sud\" ~ \"Anjanaharibe_sud\",\n    nom == \"Iles Radama/Sahamalaza\" ~ \"Sahamalaza Iles Radama\",\n    nom == \"Kalambatritra\" ~ \"Kalambatrika\",\n    nom == \"Mananara-Nord\" ~ \"Mananara Nord\",\n    nom == \"Kirindy - Mitea\" ~ \"Kirindy Mite\",\n    nom == \"Midongy du Sud\" ~ \"Befotaka Midongy\", # Vérifié sur la carte\n    nom == \"Montagne d'Ambre/Forêt d'Ambre\" ~ \"Montagne d'Ambre\",\n    nom == \"Tsimanampesotsa\" ~ \"Tsimanampesotse\",\n    nom == \"Pic d'Ivohibe\" ~ \"Ivohibe\",\n    nom == \"Forêt Naturelle de Petriky\" ~ \"Forêt Naturel de Petriky\",\n    nom == \"Tsingy de Namoroka\" ~ \"Namoroka\",\n    nom == \"Réserve de Ressources Naturelle Mahimborondro\" ~ \"Mahimborondro\",\n    str_detect(nom, \"Complexe Tsimembo Manambolomaty\") ~ \"Complexe Tsimembo Manambolomaty\",\n    nom == \"Mandrozo\" ~ \"Zone Humide de Mandrozo\",\n    nom == \"Paysage Harmonieux Protégés Bemanevika\" ~ \"Complexe des Zones Humides de Bemanevika\",\n    nom == \"Nord Ifotaky\" ~ \"INord fotaky\",\n    TRUE ~ nom)) %>%\n  arrange(nom_wdpa) %>%\n  mutate(rownum = row_number())\n\n# On ne garde que les aires de WDPA qui apparaissent dans Vahatra\nWDPA_commun <- WDPA_Mada %>%\n  filter(NAME %in% AP_Vahatra$nom_wdpa) %>%\n  filter(!(NAME == \"Analalava\" & IUCN_CAT == \"Not Reported\")) %>%\n  filter(!(NAME == \"Site Bioculturel d'Antrema\" & IUCN_CAT == \"Not Reported\")) %>%\n  filter(DESIG != \"UNESCO-MAB Biosphere Reserve\") %>%\n  arrange(NAME)  %>%\n  mutate(rownum = row_number())\n       \n# Cette fonction calcule la part d'un polygone incluse dans un \n# autre polygone et retourne un ratio entre 0 et 1\nratio_inclus <- function(x, y) {\n  inclus <- st_intersection(x, y)\n  ratio <- st_area(inclus) / st_area(x)\n  return(ratio)\n}\n\n# On calcule la part des polygones Vahatra incluse dans les polgones WDPA \nV_in_W <- map2_dbl(WDPA_commun$geometry, AP_Vahatra$geometry, ratio_inclus)\n# Puis l'inverse\nW_in_V <- map2_dbl(AP_Vahatra$geometry, WDPA_commun$geometry, ratio_inclus)\n# On fait un facteur des deux\nrecoupement_mutuel <- V_in_W * W_in_V\n# Qu'on ramène dans les jeux de données d'origine\nWDPA_commun2 <- bind_cols(WDPA_commun, V_in_W = V_in_W, W_in_V = W_in_V,\n                         recoupement_mutuel = recoupement_mutuel) %>%\n  arrange(recoupement_mutuel, rownum)\nAP_Vahatra2 <- bind_cols(AP_Vahatra, V_in_W = V_in_W, W_in_V = W_in_V,\n                        recoupement_mutuel = recoupement_mutuel) %>%\n  arrange(recoupement_mutuel, rownum)\n\n# On prend maintenant les 5 les plus éloignés et on les visualise\nmin_recoup <- WDPA_commun2 %>%\n  filter(row_number() <= 10) %>%\n  select(nom_wdpa = NAME, rownum) %>%\n  mutate(source = \"WDPA\") %>%\n  bind_rows(select(filter(AP_Vahatra2, rownum %in% .$rownum), nom_wdpa, rownum)) %>%\n  mutate(source = ifelse(is.na(source), \"Vahatra\", source))\ntmap_mode(\"plot\")\nmin_recoup %>%\n  tm_shape() +\n  tm_polygons() +\n  tm_facets(by = c(\"nom_wdpa\", \"source\"))\n\n\n\n\n\nOn peut également comparer ceux pour lesquels on a des différences de date ou de statut.\n\n\nCode\n# On garde seulement les métadonnées qu'on veut comparer\nWDPA_a_comparer <- WDPA_commun %>% # On repart des AP communes\n  st_drop_geometry() %>% # Plus besoin de spatial\n  select(nom_wdpa = NAME, type_wdpa = INT_CRIT, cat_iucn_wdpa = IUCN_CAT,\n         year_wdpa = STATUS_YR) # On ne garde que les colonnes à comparer\n\nverif_meta_wdpa <-AP_Vahatra %>%\n  st_drop_geometry() %>% # Pas besoin d'un jeu spatial\n  select(nom:date_modification, nom_wdpa) %>% # colonnes à garder dans Vahatra\n  # On renomme la catégorie IUCN de Vahatra et on code les NA comme dans WDPA\n  mutate(cat_iucn = ifelse(is.na(cat__iucn), \"Not Reported\", cat__iucn)) %>%\n  relocate(cat_iucn, .before = cat__iucn) %>% # Nouvelle colonne près de l'ancienne\n  left_join(WDPA_a_comparer, by = \"nom_wdpa\") %>% # On rassemble Vahatra et WDPA\n  select(-nom_wdpa, -cat__iucn) %>% # On enlève les colonnes inutiles\n  # On compare les dates et statuts\n  mutate(`Différence de date` = year(date_creation) != year_wdpa,\n         `Différence de statut` = cat_iucn != cat_iucn_wdpa)\n\nverif_meta_wdpa %>%\n  summarise(`Nombre d'aires protégées comparées` = n(),\n            `Différence de date` = sum(`Différence de date`),\n            `Différence de statut` = sum(`Différence de statut`)) %>%\n  gt() %>%\n  tab_header(title = paste(\"Différences entre les données de WDPA et celles de\",\n                     \"l'assciation Vahatra sur les aires protégées terrestres\",\n                     \"à Madagascar\"))\n\n\n\n\n\n\n  \n    \n      Différences entre les données de WDPA et celles de l'assciation Vahatra sur les aires protégées terrestres à Madagascar\n    \n    \n  \n  \n    \n      Nombre d'aires protégées comparées\n      Différence de date\n      Différence de statut\n    \n  \n  \n    98\n68\n40\n  \n  \n  \n\n\n\n\nDans les cas qu’on peut comparer, les données de l’association Vahatra semblent plus fiables. On va donc privilégier l’utilisation de ces dernières.\nOn va également visualiser les aires de WDPA qui ne sont pas contenues dans Vahatra.\n\n\nCode\nWDPA_exclu <- WDPA_Mada %>%\n  filter(!(NAME %in% AP_Vahatra$nom_wdpa))\n\ntmap_mode(\"view\")\nWDPA_exclu %>%\n  tm_shape() +\n  tm_polygons(col = \"IUCN_CAT\")\n\n\n\n\n\n\n\nCode\nratio_terrestre <- function(x) {\n  inclus <- st_intersection(x, contour_mada$geometry)\n  ratio <- st_area(inclus) / st_area(x)\n  return(ratio)\n}\n\n# On crée un grand polygone avec toutes les AP dans Vahatra\nAP_Vahatra_fusion <- st_union(AP_Vahatra)\n\n# On calcule pour les aires protégées de WDPA qui ne sont pas dans Vahatra\n# dans quelle mesure elles sont terrestres et pas superposées à d'autres AP\n# déjà dans Vahatra\nWDPA_exclu <- WDPA_exclu %>%\n  filter(st_geometry_type(.) == \"MULTIPOLYGON\") %>%\n  mutate(part_terrestre = map2_dbl(.$geometry, contour_mada$geometry, \n                                   ratio_inclus),\n         part_deja_autre = map2_dbl(.$geometry, AP_Vahatra_fusion, \n                                    ratio_inclus))\n\n# On garde celles qui sont au moins 25% terrestre et 75% pas superposées\nWDPA_a_inclure <- WDPA_exclu %>%\n  filter(part_terrestre >= 0.25 & part_deja_autre <= 0.25) %>%\n  mutate(full_name = paste(INT_CRIT, NAME)) %>%\n  select(nom = NAME, WDPAID, full_name, creation = STATUS_YR)\n\n\nOn a visiblement des aires protégées qu’il serait pertinent d’inclure et qui ne sont pas dans Vahatra."
  },
  {
    "objectID": "01-aires_protegees.html#enjeux-de-fiabilité-des-données-daires-protégées",
    "href": "01-aires_protegees.html#enjeux-de-fiabilité-des-données-daires-protégées",
    "title": "1  Aires protégées",
    "section": "1.4 Enjeux de fiabilité des données d’aires protégées",
    "text": "1.4 Enjeux de fiabilité des données d’aires protégées\nImportant pour l’analyse : si périmètres pas juste => phénomènes de leakage, faux positifs ou faux négatifs.\nEnjeu aussi des métadonnées : date ou type sont importants pour l’analyse et celle-ci perd en fiabilité si ces informations ne sont pas correctes.\n\n\n\n\nGoodman, Steven M., Marie Jeanne Raherilalao, Sébastien Wohlhauser, Jean Clarck N. Rabenandrasana, Herivololona M. Rakotondratsimba, Fanja Andriamialisoa, and Malalarisoa Razafimpahanana. 2018. Les Aires Protégées Terrestres de Madagascar: Leur Histoire, Description Et Biote. Association Vahatra."
  },
  {
    "objectID": "03-donnees_deforestation.html#mapme",
    "href": "03-donnees_deforestation.html#mapme",
    "title": "3  Couvert forestier",
    "section": "3.1 Mapme",
    "text": "3.1 Mapme"
  },
  {
    "objectID": "03-donnees_deforestation.html#google-earth-engine",
    "href": "03-donnees_deforestation.html#google-earth-engine",
    "title": "3  Couvert forestier",
    "section": "3.2 Google Earth Engine",
    "text": "3.2 Google Earth Engine\nPour aller plus loin : https://r-earthengine.com/rgeebook/"
  },
  {
    "objectID": "03-donnees_deforestation.html#tmf",
    "href": "03-donnees_deforestation.html#tmf",
    "title": "3  Couvert forestier",
    "section": "3.3 TMF",
    "text": "3.3 TMF\nFichiers préparés en python (code à venir), directement sur les rasters.\n\n\nCode\nlibrary(readxl)\nbase <- \"https://github.com/fBedecarrats/conservation-deforestation-madagascar\"\nfile1 <- \"files/9828838/TMFdegradationYear_AP_Vahatra.xlsx\"\nfile2 <- \"files/9828842/TMFdeforestationYear_AP_Vahatra.xlsx\"\n\ndownload.file(url = paste(base, file1, sep = \"/\"),\n              destfile = \"data/TMFdegradationYear_AP_Vahatra.xlsx\")\ndownload.file(url = paste(base, file1, sep = \"/\"),\n              destfile = \"data/TMFdeforestationYear_AP_Vahatra.xlsx\")\n\ntmf_vahatra <- read_excel(\"data/TMFdeforestationYear_AP_Vahatra.xlsx\")\ntmf_vahatra_deg <- read_excel(\"data/TMFdegradationYear_AP_Vahatra.xlsx\")"
  },
  {
    "objectID": "03-donnees_deforestation.html#alternatives",
    "href": "03-donnees_deforestation.html#alternatives",
    "title": "3  Couvert forestier",
    "section": "3.4 Alternatives",
    "text": "3.4 Alternatives"
  },
  {
    "objectID": "09-bibliographie.html",
    "href": "09-bibliographie.html",
    "title": "References",
    "section": "",
    "text": "Bédécarrats, Florent, and Alexandre Hobeika. 2017. “Une\nAlternative à Word : Écrire En\nRMarkdown.” Billet. Data Sciences Sociales.\nhttp://data.hypotheses.org/1144.\n\n\nGoodman, Steven M., Marie Jeanne Raherilalao, Sébastien Wohlhauser, Jean\nClarck N. Rabenandrasana, Herivololona M. Rakotondratsimba, Fanja\nAndriamialisoa, and Malalarisoa Razafimpahanana. 2018. Les Aires\nProtégées Terrestres de Madagascar: Leur Histoire,\nDescription Et Biote. Association Vahatra.\n\n\nKluve, Jochen, Johannes Schielain, Melvin Wong, and Yota Eilers. 2022.\n“The KfW Protected Areas\nPortfolio: A Rigorous Impact\nEvaluation.” Frankfürt."
  },
  {
    "objectID": "10-fondamentaux_R.html#principes-élémentaires-de-manipulation-de-données-en-r",
    "href": "10-fondamentaux_R.html#principes-élémentaires-de-manipulation-de-données-en-r",
    "title": "9  Fondamentaux pour l’utilisation de R",
    "section": "9.1 Principes élémentaires de manipulation de données en R",
    "text": "9.1 Principes élémentaires de manipulation de données en R"
  },
  {
    "objectID": "10-fondamentaux_R.html#produire-des-cartes-simples-avec-r",
    "href": "10-fondamentaux_R.html#produire-des-cartes-simples-avec-r",
    "title": "9  Fondamentaux pour l’utilisation de R",
    "section": "9.2 Produire des cartes simples avec R",
    "text": "9.2 Produire des cartes simples avec R"
  },
  {
    "objectID": "10-fondamentaux_R.html#produire-des-graphiques-avec-r",
    "href": "10-fondamentaux_R.html#produire-des-graphiques-avec-r",
    "title": "9  Fondamentaux pour l’utilisation de R",
    "section": "9.3 Produire des graphiques avec R",
    "text": "9.3 Produire des graphiques avec R"
  }
]